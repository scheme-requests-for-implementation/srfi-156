<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.2//EN">
<html>
  <head>
    <title>Syntactic combiners for binary predicates</title>
    <link href="../srfi-common/admin.css" rel="stylesheet">
    <link href="../srfi-common/list.css" rel="stylesheet">
    <link href="../srfi-common/favicon.png" rel="icon" sizes="192x192" type="image/png">
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
     });
    </script>
    <script crossorigin="anonymous" integrity=
            "sha384-Ra6zh6uYMmH5ydwCqqMoykyf1T/+ZcnOQfFPhDrp2kI4OIxadnhsvvA2vv9A7xYv" src=
            "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
            type="text/javascript"></script>
  </head>

  <body>
    <h1>SRFI 156: Syntactic combiners for binary predicates</h1>
    <p class="authors">by Panicz Maciej Godek</p>
    <p class="status">status: <em>draft</em> (2017/7/10)</p>

    <ul class="info">
      <li><a href="srfi-156.html">The SRFI Document</a></li>
      <li><a href="https://srfi-email.schemers.org/srfi-156/">Discussion Archive</a></li>
      <li><a href="https://github.com/scheme-requests-for-implementation/srfi-156">Git repo (on Github)</a></li>
      <li>
        <a href="mailto:srfi-156@srfi.schemers.org">srfi-156@<span class="antispam">nospam</span>srfi.schemers.org (subscribers only)</a></li>
      <li>
        <form method="POST" action="https://www.simplelists.com/subscribe.php">
          <div class="title">Subscribe to srfi-156 mailing list</div>
          <input name="email"
                 placeholder="email address"
                 tabindex="1"
                 type="email" >
          <input name="name"
                 placeholder="full name"
                 tabindex="2"
                 type="text" >
          <p>
            <input id="sub-digest"
                   name="digest"
                   tabindex="3"
                   type="checkbox"
                   value="digest" >
            <label for="sub-digest">daily digest?</label></p>
          <input class="submit"
                 name="submit"
                 tabindex="4"
                 type="submit"
                 value="Subscribe to srfi-156" >
          <input type="hidden" name="action" value="subscribe">
          <input type="hidden" name="list" value="srfi-156@srfi.schemers.org"></form></li>
      <li>
        <form method="POST" action="https://www.simplelists.com/subscribe.php">
          <p class="title">Unsubscribe from srfi-156 mailing list</p>
          <input name="email"
                 placeholder="email address"
                 tabindex="5"
                 type="email" >
          <input class="submit"
                 name="submit"
                 tabindex="6"
                 type="submit"
                 value="Unsubscribe from srfi-156" >
          <input name="action"
                 type="hidden"
                 value="unsubscribe" >
          <input name="list"
                 type="hidden"
                 value="srfi-156@srfi.schemers.org"></form></li></ul>
    <h2>Abstract</h2>      <p>The power and universality of the prefix
      notation employed by Scheme and other dialects of Lisp can be
      intimidating. However, we find that there are occasions when prefix
      syntax can be confusing and lead to code that is not self-documenting. We
      have identified that one of such cases is the use of asymmetrical binary
      predicates.
      <p>Probably the most common examples are the
      numerical comparison predicates <code>&lt;</code>, <code>&lt;=</code>,
      <code>&gt;=</code> and <code>&gt;</code>. It is non obvious, for
      instance, how the expression <code>(&lt; a b)</code> should be
      pronounced.
      <p>The problem gets more serious in the case of
      user-defined binary predicates. For example, in the expression
      <code>(divides? x y)</code> the role of arguments is unclear: we don't
      know whether the author of the <code>divides?</code> predicate intended
      it to check whether <code>x</code> divides <code>y</code> or whether
      <code>y</code> divides <code>x</code>.
      <p>And while there seems to exist a silent
      convention among Schemers to interpret predicates like
      <code>(has-something-to? x y)</code> as "<code>x</code> has something to
      <code>y</code>", we believe that this convention should be made explicit,
      and confirmed by the forms available in the language.
      <p>We therefore propose a thin layer of "syntactic
      stevia" that can be implemented using regular Scheme macros. We suggest,
      that the code <code>(is x &lt; y)</code> should be transformed to
      <code>(&lt; x y)</code>, and <code>(is x &lt; y &lt;= z)</code> -- to
      <code>(and (&lt; x y) (&lt;= y z))</code>. In addition, we suggest
      special meaning to the <code>_</code> symbol: <code>(is _ &lt; y)</code>
      and <code>(is x &lt; _)</code> should be transformed to <code>(lambda (_)
      (&lt; _ y))</code> and <code>(lambda (_) (&lt; x _))</code>,
      respectively. This SRFI document also describes some other uses of the
      <code>is</code> macro and its limitations.</body></html>